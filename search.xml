<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[左旋转字符串]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[左旋转字符串 字符序列S=”abcXYZdef” 要求输出循环左移3位后的结果 即“XYZdefabc” 12345678910public static String LeftRotateString(String str, int n) &#123; if (str == null || str.length() == 0 || n &lt; 0) &#123; return ""; &#125; StringBuilder sb = new StringBuilder(str); int len = str.length(); n = n % len; sb.append(str); return sb.substring(n, len + n); &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的第k个结点]]></title>
    <url>%2F2018%2F10%2F05%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[求 二叉搜索树的第k个结点 给定一颗二叉搜索树，请找出其中的第k大的结点。 例如: 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 12345678910111213141516171819202122public static TreeNode KthNode(TreeNode pRoot, int k) &#123; if (pRoot == null || k &lt; 1) &#123; return null; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); int count = 0; TreeNode KthNode = null; while (pRoot != null || !stack.isEmpty()) &#123; while (pRoot != null) &#123; stack.push(pRoot); pRoot = pRoot.left; &#125; TreeNode node = stack.pop(); count++; if(count == k)&#123; KthNode = node; &#125; pRoot = node.right; &#125; return KthNode;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中未出现的最小正整数]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数组中未出现的最小正整数 arr=[-1,2,3,4] 返回 1 arr=[1,2,3,4] 返回 5 1234567891011121314151617181920212223public static int missNum(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; int l = 0; //目前已收集 1 ~ l 上的数 int r = arr.length; // 后续最优的情况下 能收集 1 ~ r 上的数 while (l &lt; r) &#123; if (arr[l] == l + 1) &#123; l++; &#125; else if (arr[l] &lt; l || arr[l] &gt; r || arr[arr[l] - 1] == arr[l]) &#123; r--; &#125; else &#123; swap(arr, l, arr[l] - 1); &#125; &#125; return l + 1; &#125; public static void swap(int[] arr, int low, int high) &#123; int temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中超过一半的数]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[原题 :（数组中超过一半（N/2）的数） 进阶 : 找到出现次数超过N/K的数 tips : 原题一个候选数 一次删2个 进阶题 一次k-1个候选数 一次删k个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void pirntKMajor(int[] arr, int k) &#123; if (k &lt; 2) &#123; System.out.println("the value of k is invalid"); return; &#125; HashMap&lt;Integer, Integer&gt; cands = new HashMap&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; if (cands.containsKey(arr[i])) &#123; cands.put(arr[i], cands.get(arr[i]) + 1); &#125; else &#123; if (cands.size() == k - 1) &#123; allCandsMinsusOne(cands); &#125; else &#123; cands.put(arr[i], 1); &#125; &#125; &#125; HashMap&lt;Integer, Integer&gt; reals = getReals(arr, cands); boolean print = false; for (Map.Entry&lt;Integer, Integer&gt; set : reals.entrySet()) &#123; int value = set.getValue(); int key = set.getKey(); if (value &gt; arr.length / k) &#123; print = true; System.out.print(key + " "); &#125; &#125; System.out.println(print ? "" : "no such number"); &#125; private static HashMap&lt;Integer, Integer&gt; getReals(int[] arr, HashMap&lt;Integer, Integer&gt; cands) &#123; HashMap&lt;Integer, Integer&gt; reals = new HashMap&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; if (cands.containsKey(arr[i])) &#123; if (reals.containsKey(arr[i])) &#123; reals.put(arr[i], reals.get(arr[i]) + 1); &#125; else &#123; reals.put(arr[i], 1); &#125; &#125; &#125; return reals; &#125; private static void allCandsMinsusOne(HashMap&lt;Integer, Integer&gt; map) &#123; List&lt;Integer&gt; removeList = new LinkedList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123; int key = set.getKey(); int value = set.getValue(); if (value == 1) &#123; removeList.add(key); &#125; else &#123; map.put(key, value - 1); &#125; &#125; for (Integer removeKey : removeList) &#123; map.remove(removeKey); &#125; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最小的K个数]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个无序数组，找到其中最小的K个数 利用最大堆,只要维护堆内有k个数即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//利用最大堆public static int[] getMinKNumByHeap(int[]arr ,int k)&#123; if(arr==null ||arr.length&lt;k|| k&lt;0)&#123; return null; &#125; int[] kHeap = new int[k]; for(int i =0 ; i&lt;k; i++)&#123; heapInsert(kHeap,arr[i],i); &#125; for(int i=k; i&lt;arr.length; i++)&#123; if(kHeap[0]&gt;arr[i])&#123; kHeap[0] = arr[i]; heapify(kHeap, 0, k); &#125; &#125; return kHeap;&#125; //建堆的过程public static void heapInsert(int[] heap, int value, int index)&#123; heap[index] = value; int parent = (index-1)/2; while(index!=0)&#123; if(heap[index]&gt;heap[parent])&#123; swap(heap,index,parent); index = parent; &#125;else&#123; break; &#125; &#125;&#125;//调整的过程public static void heapify(int[] heap, int index, int heapSize)&#123; int left = 2*index +1; int right = 2*index +2; int largest = index; while(left &lt; heapSize)&#123; if(heap[index]&lt;heap[left])&#123; //swap(heap,index,left); largest = left; &#125; if(right &lt; heapSize &amp;&amp; heap[largest]&lt;heap[right])&#123; largest = right; &#125; if(index!=largest)&#123; swap(heap,index,largest); &#125;else&#123; break; &#125; index = largest; left = 2*index +1; right = 2*index +2; &#125;&#125;public static void swap(int[] arr, int low, int high)&#123; int temp = arr[low]; arr[low] = arr[high]; arr[high] = temp;&#125; 快排思想, 无需全部排序,保证前k个数有序即可 12345678910111213141516171819202122232425262728293031323334353637public static int partition(int[] arr,int start,int end)&#123; if(arr==null || arr.length==0)&#123; return -1; &#125; int l = start; int r = end; int temp = arr[l]; if(l&lt;r)&#123; while(l&lt;r &amp;&amp; temp &gt;= arr[r])&#123; r--; &#125; if(l&lt;r)&#123; arr[l++]=arr[r]; &#125; while(l&lt;r &amp;&amp; temp &lt; arr[l])&#123; l++; &#125; if(l&lt;r)&#123; arr[r--] = arr[l]; &#125; &#125; arr[l] = temp; return l;&#125;//利用快排思想public static void getKNum(int[] arr,int start,int end, int k)&#123; int index = partition(arr, start, end); while(index != k-1)&#123; if(index &lt; k-1)&#123; index = partition(arr, index+1, end); &#125;else if(index &gt; k-1)&#123; index = partition(arr, start, index-1); &#125;else&#123; return; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最长子数组]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[在未排序数组中 找到和为k的最长子数组长度 12345678910111213141516171819202122public static int maxLength(int[] arr, int k) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; //这个map表示key第一次出现在value下标的位置 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //表示 合为0 第一次出现在-1位置 map.put(0, -1); int len = 0; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; if (map.containsKey(sum - k)) &#123; len = Math.max(i - map.get(sum - k), len); &#125; if (!map.containsKey(sum)) &#123; map.put(sum, i); &#125; &#125; return len; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转链表 1234567891011121314151617181920212223242526272829303132333435363738// 非递归public static Node reverseUnRecur(Node head) &#123; if (head == null || head.next == null) &#123; return head; &#125; Node pre = null; Node next = null; Node cur = head; while (cur != null) &#123; //记住当前节点的 next.next = cur.next; // 当前节点指向前一个节点 cur.next = pre; // 让pre记住当前节点 pre = cur; // 当前节点后移 cur = next; &#125; return pre; &#125; // 递归 public static Node reverseRecur(Node head) &#123; if (head == null || head.next == null) &#123; return head; &#125; Node next = head.next; head.next = null; Node revNode = reverseRecur(next); next.next = head; return revNode; &#125; class Node &#123; int val; Node next; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序邻数差值]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%8E%92%E5%BA%8F%E9%82%BB%E6%95%B0%E5%B7%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[简述求数组排序后相邻数的最大差值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static int maxGap(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; return 0; &#125; int len = arr.length; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for(int i = 0; i &lt;len; i++)&#123; max = Math.max(arr[i], max); min = Math.min(arr[i], min); &#125; if(max == min)&#123; return 0; &#125; int[] maxArr = new int[len+1]; int[] minArr = new int[len+1]; boolean[] hasNum = new boolean[len + 1]; int k = 0; for(int i = 0; i &lt; len; i++)&#123; k = getBucket(arr[i], max, min, len); maxArr[k] = hasNum[k] ? Math.max(arr[i], maxArr[k]) : arr[i]; minArr[k] = hasNum[k] ? Math.min(arr[i], minArr[k]) : arr[i]; hasNum[k] = true; &#125; int lastMax = 0; int nextMin = 0; int i = 0; for(; i&lt;len; i++)&#123; if(!hasNum[i])&#123; lastMax = maxArr[i-1]; break; &#125; &#125; while(i&lt;len+1)&#123; if(hasNum[i])&#123; nextMin = minArr[i]; break; &#125; i++; &#125; return nextMin - lastMax;&#125;/** * 计算进入哪个桶 max直接放入n+1桶中 */public static int getBucket(int num, int max, int min, int len)&#123; return ((num - min) * len) / (max - min);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617public class hanoi &#123; public static void hanoi(int n)&#123; if(n &gt; 0) &#123; fun(n, ”LEFT”, ”MID”, ”RIGHT”); &#125; &#125; public static void fun(int n, String from, String mid, String to) &#123; if(n == 1) &#123; System.out.println(“move from ” + from + ” to ” + to); &#125; else &#123; fun(n-1, from, to, mid); fun(1, from, mid, to); fun(n-1, mid, from, to); &#125; &#125; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[左右差值绝对值最大]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%B7%A6%E5%8F%B3%E5%B7%AE%E5%80%BC%E7%BB%9D%E5%AF%B9%E5%80%BC%E6%9C%80%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[题目 给定一个长度为N(N&gt;1)的整型数组arr，可以划分成左右两个部分， 左部分arr[0..K]，右部分arr[K+1..N-1]，K可以取值的范围是[0,N-2]。 求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值， 最大是多少？例如[2,7,3,1,1]，当左部分为[2,7]，右部分为[3,1,1]时， 左部分中的最大值减去右部分最大值的绝对值为4。当左部分为[2,7,3]， 右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6。 还有很多划分方案，但最终返回6。 12345678public static int maxABS(int[] arr)&#123; int max = Integer.MIN_VALUE; for(int i = 0; i &lt; arr.length; i++)&#123; max = Math.max(max, arr[i]); &#125; return max - Math.min(arr[0], arr[arr.length - 1]);&#125; 最优解，时间复杂度O(N)，额外空间复杂度O(1)。先求整个arr的最大值max， 因为max是全局最大值，所以不管怎么划分，max要么会成为左部分的最大值， 要么会成为右部分的最大值。如果max作为左部分的最大值， 接下来我们只要让右部分的最大值尽量小就可以了。 右部分的最大值怎么尽量小呢？ 右部分只含有arr[N-1]的时候就是尽量小的时候。同理， 如果max作为右部分的最大值，只要让左部分的最大值尽量小就可以了， 左部分只含有arr[0]的时候就是尽量小的时候。 所以整个求解过程会变得异常简单]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随机函数rand1To7]]></title>
    <url>%2F2018%2F10%2F04%2F%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0rand1To7%2F</url>
    <content type="text"><![CDATA[简述请用rand1To5实现等概率随机产生1~7的随机函数rand1To7 123456789public class rand1to5 &#123; /* * 给定一个等概率随机产生1~5的随机函数rand1To5如下 public int rand1To5() &#123; return (int) * (Math.random() * 5) + 1; &#125; 除此之外不能使用任何额外的随机机制， * 请用rand1To5实现等概率随机产生1~7的随机函数rand1To7。 */ public int rand1To5() &#123; return (int) (Math.random() * 5) + 1; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public int rand1To7() &#123; int num = 0; do &#123; num = 5 * (rand1To5() - 1) + rand1To5() - 1;// 0-24 &#125; while (num &gt; 20); // 把21 22 23 24 的概率平摊到0-20上 return num % 7 + 1;&#125;// 拓展： 1-m 等概率 转化成 等1-n概率 问题// 实质就是看 把 m 看成m进制 n&lt;m 则 m进制能装下n// m&gt;n 扩充成m^2 也就是增加一位 看能不能放下n 以此类推// 给定一个以p概率产生0，以1-p概率产生1的随机函数rand01p如下：// 除此之外不能使用任何额外的随机机制，请用rand01p实现等概率随机// 产生1~6的随机函数rand1To6。public int rand01p() &#123; // you can change p as you like double p = 0.83; return Math.random() &lt; p ? 0 : 1;&#125;public int rand01() &#123; int num = 0; do &#123; num = rand01p(); &#125; while (num == rand01()); // 01 和 10 产生的概率是相同的 把1看做01 0看做10 return num == 1 ? 1 : 0;&#125;public int rand0To3() &#123; return rand01() * 2 + rand01();&#125;public int rand1To6() &#123; int num = 0; do &#123; num = rand0To3() * 4 + rand0To3(); &#125; while (num &gt; 11); return num % 6 + 1;&#125;// 其实就是一个扩大 补位 然后筛选的过程]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2018%2F10%2F04%2F%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567891011121314151617181920212223242526272829/* * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root = reConstructBinaryTree(pre, 0, pre.length - 1, in ,0, in.length - 1); return root; &#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre &gt; endPre || startIn &gt; endIn) return null; TreeNode root = new TreeNode(pre[startPre]); for(int i = startIn; i &lt;= endIn; i++) if(in[i] == pre[startPre]) &#123; root.left = reConstructBinaryTree(pre, startPre + 1, startPre + i - startIn, in, startIn, i - 1); root.right = reConstructBinaryTree(pre, i - startIn+startPre + 1, endPre, in, i + 1, endIn); &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合并两个排序的链表]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public ListNode merge(ListNode list1,ListNode list2) &#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; ListNode res = null; if(list1.val &gt; list2.val)&#123; res = list2; res.next = merge(list1,list2.next); &#125;else&#123; res = list1; res.next = merge(list1.next,list2); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树的子结构]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目描述输入两颗二叉树A，B，判断B是不是A的子结构。 123456789101112131415161718192021222324252627282930313233343536373839404142public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root2 == null)&#123; return false; &#125; if(root1 == null ) &#123; return false; &#125; boolean flag = false; flag = IsSubtree(root1,root2); if(!flag)&#123; flag = HasSubtree(root1.left, root2); if(!flag)&#123; flag = HasSubtree(root1.right, root2); &#125; &#125; return flag; &#125; private boolean IsSubtree(TreeNode root1,TreeNode root2)&#123; if(root2 == null)&#123; return true; &#125; if(root1 == null ) &#123; return false; &#125; if(root1.val == root2.val)&#123; return IsSubtree(root1.left, root2.left) &amp;&amp; IsSubtree(root1.right, root2.right); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的镜像]]></title>
    <url>%2F2018%2F10%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 1234567891011121314151617181920212223public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public void mirror(TreeNode root) &#123; if(root == null)&#123; return; &#125; TreeNode temp = root.left; root.left = root.right; root.right = temp; mirror(root.left); mirror(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树中和为某一值的路径]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Stack;public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target)&#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(root == null)&#123; return pathList; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); findPath(root, target, stack, pathList); return pathList; &#125; private void findPath(TreeNode root, int target, Stack&lt;Integer&gt; path, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathList) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null)&#123; if(root.val == target)&#123; ArrayList&lt;Integer&gt; ValList = new ArrayList&lt;Integer&gt;(); for(int i : path)&#123; ValList.add(i); &#125; ValList.add(root.val); pathList.add(ValList); &#125; &#125; else &#123; path.push(new Integer(root.val)); findPath(root.left, target-root.val, path, pathList); findPath(root.right, target-root.val, path, pathList); path.pop(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树与双向链表]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 1234567891011121314151617181920212223242526272829303132333435public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree == null)&#123; return null; &#125; TreeNode left = Convert(pRootOfTree.left); TreeNode p = left; while(p != null &amp;&amp; p.right != null)&#123; p = p.right; &#125; if(left != null)&#123; p.right = pRootOfTree; pRootOfTree.left = p; &#125; TreeNode right = Convert(pRootOfTree.right); p = right; while(p != null &amp;&amp; p.left != null)&#123; p = p.left; &#125; if(right != null)&#123; right.left = pRootOfTree; pRootOfTree.right = right; &#125; return left != null ? left : pRootOfTree; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 123456789101112131415161718192021222324252627282930public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; // int res = 0; if(array == null || array.length == 0)&#123; return 0; &#125; int count = 1; int temp = array[0]; for(int i=1; i &lt; array.length; i++)&#123; if(array[i] == temp)&#123; count++; &#125;else&#123; count--; if(count &lt; 1)&#123; temp = array[i]; count = 1; &#125; // count--; &#125; &#125; int num=0; for(int i = 0 ;i &lt; array.length; i++)&#123; if(array[i] == temp)&#123; num++; &#125; &#125; int len = array.length / 2; return num &gt; len ? temp : 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2018%2F10%2F03%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？ 12345678910111213141516public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; if(array == null || array.length == 0)&#123; return 0; &#125; int max = Integer.MIN_VALUE; int temp = 0; for(int i=0; i &lt; array.length; i++)&#123; temp += array[i]; max = Math.max(max, temp); temp = temp &lt; 0 ? 0 : temp; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) &#123; return 0; &#125; if(index &lt;= 5) &#123; return index; &#125; int[] array = new int[index]; array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; array[4] = 5; for(int i = 5;i &lt; index; i++) &#123; int min = 0; int min2 = 0, min3 = 0, min5 = 0; int temp = 0; //找到已知的丑数的2倍的数，且该数比已知最大丑数大。 for(int j = 0; j &lt; i; j++) &#123; temp = array[j] * 2; if(temp &gt; array[i-1]) &#123; min2 = temp; break; &#125; &#125; //同上，3倍 for(int j = 0;j &lt; i; j++) &#123; temp = array[j] * 3; if(temp &gt; array[i-1]) &#123; min3 = temp; break; &#125; &#125; //同上，5倍 for(int j = 0; j &lt; i; j++) &#123; temp = array[j] * 5; if(temp &gt; array[i-1])&#123; min5 = temp; break; &#125; &#125; min = Math.min(Math.min(min2, min3), min5); array[i] = min; &#125; return array[index-1]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 12345678910111213141516171819public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if(root==null)&#123; return true; &#125; if(Math.abs(TreeHeight(root.left) - TreeHeight(root.right)) &lt;= 1) &#123; return IsBalanced_Solution(root.left)&amp;&amp;IsBalanced_Solutio(root.right); &#125;else&#123; return false; &#125; &#125; public int TreeHeight(TreeNode root)&#123; if(root == null) &#123; return 0; &#125; return Math.max(TreeHeight(root.left), TreeHeight(root.right)) + 1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 123456789101112131415161718192021public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; int left = TreeDepth(root.left)+1; int right = TreeDepth(root.right)+1; int res = Math.max(left,right); return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public int InversePairs(int [] array) &#123; if(array == null || array.length == 0 || array.length == 1) return 0; return sort(array, 0, array.length - 1); &#125; public int sort(int[] arr, int low, int high)&#123; if(low &lt; high)&#123; int mid = (low + high) / 2; return sort(arr, low, mid) + sort(arr, mid + 1, high) + merge(arr, low, high); &#125; return 0; &#125; public int merge(int[] arr, int low, int high)&#123; int i = low; int mid = (low + high) / 2; int j = mid + 1; int result = 0; int[] tmp = new int[high - low + 1]; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= high)&#123; if(arr[i] &gt; arr[j])&#123; result++; tmp[k++] = arr[j++]; &#125;else&#123; tmp[k++] = arr[i++]; &#125; &#125; if(i &lt;= mid)&#123; result += (mid - i) * (high - mid); while(i &lt;= mid)&#123; tmp[k++] = arr[i++]; &#125; &#125;else&#123; while(j &lt;= high)&#123; tmp[k++] = arr[j++]; &#125; &#125; for(int p = 0; p &lt;= tmp.length - 1; p++)&#123; arr[low + p] = tmp[p]; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 1234567891011121314151617181920212223242526272829303132333435363738/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null)&#123; return null; &#125; //find right child's leftest child (if has right child) if(pNode.right != null)&#123; pNode = pNode.right; while(pNode.left != null)&#123; pNode = pNode.left; &#125; return pNode; &#125; //if node is not root while(pNode.next != null)&#123; //find node it is parent's left child if(pNode == pNode.next.left)&#123; //return this node's parent return pNode.next; &#125; pNode = pNode.next; &#125; //node is root and it has not right child return null; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对称的二叉树]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 12345678910111213141516171819202122232425/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; return isSymmetric(pRoot,pRoot); &#125; boolean isSymmetric(TreeNode root1,TreeNode root2)&#123; if(root1==null &amp;&amp; root2==null) return true; if(root1==null || root2==null) return false; if(root1.val!=root2.val) return false; return isSymmetric(root1.left,root2.right)&amp;&amp;isSymmetric(root1.right,root2.left); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[删除链表中重复的结点]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如: 链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728293031 public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead == null || pHead.next == null)&#123; return pHead; &#125; ListNode temp = new ListNode(0); temp.next = pHead; pHead = temp; while(pHead.next != null &amp;&amp; pHead.next.next != null) &#123; if(pHead.next.val == pHead.next.next.val) &#123; int val = pHead.next.val; while(pHead.next != null &amp;&amp; pHead.next.val == val)&#123; pHead.next = pHead.next.next; &#125; &#125; else&#123; pHead = pHead.next; &#125; &#125; return temp.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链表中环的入口结点]]></title>
    <url>%2F2018%2F10%2F03%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述一个链表中包含环，请找出该链表的环的入口结点。 1234567891011121314151617181920212223242526272829303132/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead)&#123; if(pHead == null || pHead.next == null)&#123; return null; &#125; ListNode node1 = pHead; ListNode node2 = pHead; while(node2 != null)&#123; node1 = node1.next; node2 = node2.next.next; if(node1 == node2)&#123; break; &#125; &#125; node1 = pHead; while(node1 != node2)&#123; node1 = node1.next; node2 = node2.next; &#125; return node1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[和为S的两个数字]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 123456789101112131415161718192021222324import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(array==null||array.length&lt;2)&#123; return list; &#125; int low = 0; int high = array.length-1; while(low &lt; high)&#123; if((array[low]+array[high]) == sum)&#123; list.add(array[low]); list.add(array[high]); return list; &#125;else if((array[low]+array[high]) &gt; sum)&#123; high--; &#125;else&#123; low++; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[和为S的连续正数序列]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 12345678910111213141516171819202122232425import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(sum &lt; 0)&#123; return result; &#125; for(int i=1;i&lt;=sum/2;i++)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int preSum = i; int nextNum = i; list.add(preSum); while(preSum &lt; sum)&#123; nextNum++; list.add(nextNum); if((preSum += nextNum)==sum)&#123; result.add(list); break; &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>题目汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[作者：王勐链接：https://www.zhihu.com/question/23995189/answer/35429905来源：知乎 本质动态规划的本质不在于是递推或是递归，也不需要纠结是不是内存换时间。理解动态规划并不需要数学公式介入，只是完全解释清楚需要点篇幅…首先需要明白哪些问题不是动态规划可以解决的，才能明白为神马需要动态规划。不过好处时顺便也就搞明白了递推贪心搜索和动规之间有什么关系，以及帮助那些总是把动规当成搜索解的同学建立动规的思路。当然熟悉了之后可以直接根据问题的描述得到思路，如果有需要的话再补充吧。动态规划是对于 某一类问题 的解决方法！！重点在于如何鉴定“某一类问题”是动态规划可解的而不是纠结解决方法是递归还是递推！怎么鉴定dp可解的一类问题需要从计算机是怎么工作的说起…计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑他们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）当你企图使用计算机解决一个问题是，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！ 栗子比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。非波那契那个例子过于简单，以至于让人忽视了阶段的概念，所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。非波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。想象另外一个问题情景，假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。 问题 现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。好消息是，有时候我们并不需要真的计算所有状态，比如这样一个弱智的棋盘问题：从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个弱智的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“下一步最优是从当前最优得到的”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心。如果只看最优状态之间的计算过程是不是和非波那契数列的计算很像？所以计算的方法是递推。 既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。如果一个阶段的最优无法用前一个阶段的最优得到呢？什么你说只需要之前两个阶段就可以得到当前最优？那跟只用之前一个阶段并没有本质区别。最麻烦的情况在于你需要之前所有的情况才行。 再来一个迷宫的例子。在计算从起点到终点的最短路线时，你不能只保存当前阶段的状态，因为题目要求你最短，所以你必须知道之前走过的所有位置。因为即便你当前再的位置不变，之前的路线不同会影响你的之后走的路线。这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。哦哦，刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做有后效性。刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？契机就在于后效性。有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上升子序列的例子来说明为什么他不必需要暴力搜索，进而引出动态规划的思路。 假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程 总结所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！每个阶段只有一个状态-&gt;递推；每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；而不管之前这个状态是如何得到的这个性质叫做无后效性。 另其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。但实际上有的问题往往需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jvm-内存回收与分配]]></title>
    <url>%2F2018%2F10%2F02%2Fjvm-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[JVM内存回收与分配策略 对象优先在Eden区分配 大对象直接进入老年代: 所谓大对象就是需要大量连续的内存空间的java对象长期存活的对象将进入老年代：每发生一次GC，存活的对象的年+1，当对象的年龄增加到一定程度（默认15）就会进入老年代 动态对象年龄判断 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代 空间分担担保 在发生GC之前，jvm先会检查老年代最大可用的连续内存空间是否大于新生代所有对象总空间。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jvm-垃圾回收算法简述]]></title>
    <url>%2F2018%2F10%2F02%2Fjvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[概念当jvm发现内存占比超过一定阈值时会发生young gc和full gc进行垃圾回收 垃圾回收算法 标记-清除算法首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。缺点：①效率低：标记和清除两个过程效率都不高。②空间碎片：会产生大量不连续的内存碎片，导致以后分配大对象时，无法找到足够的连续空间而不得不提前触发一次垃圾回收。 复制算法：将可用内存按容量分为大小相等的两块，每次只使用其中一块。垃圾回收之后，将还存活的对象复制到另外一块，再把使用过的内存空间一次清理掉。解决了标记-清除算法的缺点，但是每次使用的内存只有原来的二分之一。当然现代虚拟机并不是1:1来划分的，而是将内存划分为一块较大的Eden和两块较小的Survivor(From Survivor、To Survivor)空间(8:1:1)，每次只使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。我们发现每次可以使用90%的内存空间，但是如果回收后的对象超过了10%的内存怎么办，也就是其中一块Survivor放不下了。这时会有分配担保机制将这些对象进去老年代。 标记-整理算法：复制算法在对象存活率较高的情况下会变得效率低。所以老年代一般不选用复制算法。标记整理算法，标记过程和标记清除算法一样，但后续不是直接对可回收的对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存 总结当代虚拟机一般使用分代收集算法，在新生代只用复制算法，因为对象都是朝生夕死，只有少量存活。老年代使用标记-清除算法或者标记-整理算法，因为存活率比较高，没有额外的空间对它进行分配担保。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jvm-之对象生死]]></title>
    <url>%2F2018%2F10%2F02%2Fjvm-%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%AD%BB%2F</url>
    <content type="text"><![CDATA[判断java对象存活方法1.引用计数算法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一，当引用失效时，计数器就减一。任何时刻计数器为0的对象就是不能再被使用。引用计数法实现简单，效率高。但是存在一个循环引用问题。例：objA.inc = objB; objB.inc = objA; objA = null; objB = null; 2.可达性分析算法通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链。当一个对象到”GC Roots”没有任何引用链相连，即从GC Roots到这个对象不可达。则证明这个对象是不可用的。 GC Roots包括： 虚拟机栈中引用的对象 方法区中的类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 再谈引用： 强引用：类似 Object obj = new Object(); obj 就是强引用。 软引用：描述一些有用但并非必须的对象。在系统将要发生内存溢出异常时，会把这些对象列入回收范围。如果还没有足够的内存才会抛出内存溢出异常。SoftReference 弱引用：描述非必须的对象，但强度更弱。弱引用对象只能生存到下一次垃圾回收之前。无论当前内存是否足够，都会被回收掉。WeakReference 虚引用：最弱的一种引用关系。唯一的目的是能在这个对象被收集器回收时收到一个系统通知。PhantomReference 生存还是死亡：真正宣告一个对象死亡，至少压经历两次标记过程。第一次标记那些到GC Roots不可达的对象，把它们放入一个叫F-Queue的队列之中。第二次由一个jvm自动建立Finalizer线程去处理队列，对队列中的对象进行再一次标记。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jvm 对象探秘]]></title>
    <url>%2F2018%2F10%2F02%2Fjvm-%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[对象的创建:当虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类是符号引用，并且检验这个符号引用代表的类是否已被加载过。 对象的内存布局 对象头 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳 类型指针（即对象指向它类元数据的指针） 实例数据 ：各种类型的字段内容 对齐填充 ：没有特定含义，起着占位符的作用 对象的访问定位 使用句柄访问 直接指针访问 使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移到（因为垃圾回收）时只会改变句柄中到对象实例数据的指针，而reference本身不用改变。使用直接指针访问方式的最大好处是速度快，它节省一次指针定位的时间开销，由于对象的访问在java中十分频繁]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[运行时数据区域]]></title>
    <url>%2F2018%2F10%2F02%2F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JVM 运行时数据区域 主要分为两大部分：###线程私有 (即所谓的线程安全): 程序计数器:当前线程所执行的字节码（即.class文件，因为所有.java文件都需要编辑成.class文件才能运行。当然不一定就是.java文件，这里泛指所有能够在JVM上跑的程序。如）的行号指示器。JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。这个计数器就是为了线程切换后能恢复到正确的执行位置。 JVM栈: Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈针在jvm中入栈到出栈的过程。局部变量表存放了编译期间可知的各种基本数据类型（boolean、byte、short、char、int、float、double、long）、引用类型（可能是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄）、returnAddress类型. 本地方法栈:类似于JVM栈，jvm栈为java方法即字节码服务，本地方法栈为Native方法服务, ###线程共享： java堆:所有对象实例以及数组（数组难道不是对象吗？）都在堆上分配（但并不是绝对的，因为逃逸分析的成熟）逃逸分析：一个对象在方法中被创建时，当它作为参数传递给其他方法时，称为方法逃逸。当它赋值给类变量或者其他线程中的实例变量时，称为线程逃逸。这时我们就可以进行逃逸分析，如果一个对象即不是方法逃逸，又不是线程逃逸。那么我们就可以进行高效优化：1、栈上分配。2、同步消除。3、标量替换。标量指的是一个数据无法分解成更小的数据。也就是说可以将一个对象分解成其中一个或者几个字段，当然前提是这个对象不会逃逸。java堆是GC（垃圾收集器）管理的主要区域。当代收集器都是采用分代收集方法。所以java堆分为新生代，年老代。新生代又分为Eden区和Survivor区，Survivor区又分为From Survivor区和To Survivor区。 方法区:存储已被虚拟机加载进来的类信息、常量、静态变量、编译后的代码。比如Classloader引用、运行时常量池、字段数据、方法数据（即方法签名）、方法代码。 运行时常量池:运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用（字段引用、方法引用），这部分内容将在类加载后进入方法区的运行时常量池中存放。它的一个重要特征是具有动态性:运行期间也可以将新的常量放入池中。例：String类的intern()方法。 直接内存：直接内存不是虚拟机运行时数据区的一部分。但是还是会引发OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO。引入了一种基于通道（Channel）与缓冲区（Buffer）的I/0方式，它可以使用Native方法函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存引用进行操作。这样可以提高性能，因为避免了在java堆和Native堆中来回复制数据（这里有点不太明白）。个人理解是java堆是属于一个进程（即jvm进程）的。而直接内存是OS本地内存。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
</search>
